{"version":3,"file":"autocomplete.min.js","names":["res: Response","timeoutId: number","autocomplete: HTMLElement | null","autocompleteList: HTMLUListElement | null"],"sources":["../../../../../client/simple/src/js/main/autocomplete.ts"],"sourcesContent":["// SPDX-License-Identifier: AGPL-3.0-or-later\n\nimport { assertElement, http, listen, settings } from \"../core/toolkit.ts\";\n\nconst fetchResults = async (qInput: HTMLInputElement, query: string): Promise<void> => {\n  try {\n    let res: Response;\n\n    if (settings.method === \"GET\") {\n      res = await http(\"GET\", `./autocompleter?q=${query}`);\n    } else {\n      res = await http(\"POST\", \"./autocompleter\", { body: new URLSearchParams({ q: query }) });\n    }\n\n    const results = await res.json();\n\n    const autocomplete = document.querySelector<HTMLElement>(\".autocomplete\");\n    assertElement(autocomplete);\n\n    const autocompleteList = document.querySelector<HTMLUListElement>(\".autocomplete ul\");\n    assertElement(autocompleteList);\n\n    autocomplete.classList.add(\"open\");\n    autocompleteList.replaceChildren();\n\n    // show an error message that no result was found\n    if (results?.[1]?.length === 0) {\n      const noItemFoundMessage = Object.assign(document.createElement(\"li\"), {\n        className: \"no-item-found\",\n        textContent: settings.translations?.no_item_found ?? \"No results found\"\n      });\n      autocompleteList.append(noItemFoundMessage);\n      return;\n    }\n\n    const fragment = new DocumentFragment();\n\n    for (const result of results[1]) {\n      const li = Object.assign(document.createElement(\"li\"), { textContent: result });\n\n      listen(\"mousedown\", li, () => {\n        qInput.value = result;\n\n        const form = document.querySelector<HTMLFormElement>(\"#search\");\n        form?.submit();\n\n        autocomplete.classList.remove(\"open\");\n      });\n\n      fragment.append(li);\n    }\n\n    autocompleteList.append(fragment);\n  } catch (error) {\n    console.error(\"Error fetching autocomplete results:\", error);\n  }\n};\n\nconst qInput = document.getElementById(\"q\") as HTMLInputElement | null;\nassertElement(qInput);\n\nlet timeoutId: number;\n\nlisten(\"input\", qInput, () => {\n  clearTimeout(timeoutId);\n\n  const query = qInput.value;\n  const minLength = settings.autocomplete_min ?? 2;\n\n  if (query.length < minLength) return;\n\n  timeoutId = window.setTimeout(async () => {\n    if (query === qInput.value) {\n      await fetchResults(qInput, query);\n    }\n  }, 300);\n});\n\nconst autocomplete: HTMLElement | null = document.querySelector<HTMLElement>(\".autocomplete\");\nconst autocompleteList: HTMLUListElement | null = document.querySelector<HTMLUListElement>(\".autocomplete ul\");\nif (autocompleteList) {\n  listen(\"keyup\", qInput, (event: KeyboardEvent) => {\n    const listItems = [...autocompleteList.children] as HTMLElement[];\n\n    const currentIndex = listItems.findIndex((item) => item.classList.contains(\"active\"));\n    let newCurrentIndex = -1;\n\n    switch (event.key) {\n      case \"ArrowUp\": {\n        const currentItem = listItems[currentIndex];\n        if (currentItem && currentIndex >= 0) {\n          currentItem.classList.remove(\"active\");\n        }\n        // we need to add listItems.length to the index calculation here because the JavaScript modulos\n        // operator doesn't work with negative numbers\n        newCurrentIndex = (currentIndex - 1 + listItems.length) % listItems.length;\n        break;\n      }\n      case \"ArrowDown\": {\n        const currentItem = listItems[currentIndex];\n        if (currentItem && currentIndex >= 0) {\n          currentItem.classList.remove(\"active\");\n        }\n        newCurrentIndex = (currentIndex + 1) % listItems.length;\n        break;\n      }\n      case \"Tab\":\n      case \"Enter\":\n        if (autocomplete) {\n          autocomplete.classList.remove(\"open\");\n        }\n        break;\n      default:\n        break;\n    }\n\n    if (newCurrentIndex !== -1) {\n      const selectedItem = listItems[newCurrentIndex];\n      if (selectedItem) {\n        selectedItem.classList.add(\"active\");\n\n        if (!selectedItem.classList.contains(\"no-item-found\")) {\n          const qInput = document.getElementById(\"q\") as HTMLInputElement | null;\n          if (qInput) {\n            qInput.value = selectedItem.textContent ?? \"\";\n          }\n        }\n      }\n    }\n  });\n}\n"],"mappings":"+DAIA,MAAM,EAAe,MAAO,EAA0B,IAAiC,CACrF,GAAI,CACF,IAAIA,EAEJ,AAGE,EAHE,EAAS,SAAW,MAChB,MAAM,EAAK,MAAO,qBAAqB,KAEvC,MAAM,EAAK,OAAQ,kBAAmB,CAAE,KAAM,IAAI,gBAAgB,CAAE,EAAG,EAAO,EAAG,EAGzF,IAAM,EAAU,MAAM,EAAI,OAEpB,EAAe,SAAS,cAA2B,iBACzD,EAAc,GAEd,IAAM,EAAmB,SAAS,cAAgC,oBAOlE,GANA,EAAc,GAEd,EAAa,UAAU,IAAI,QAC3B,EAAiB,kBAGb,IAAU,IAAI,SAAW,EAAG,CAC9B,IAAM,EAAqB,OAAO,OAAO,SAAS,cAAc,MAAO,CACrE,UAAW,gBACX,YAAa,EAAS,cAAc,eAAiB,mBACtD,EACD,EAAiB,OAAO,GACxB,MACD,CAED,IAAM,EAAW,IAAI,iBAErB,IAAK,IAAM,KAAU,EAAQ,GAAI,CAC/B,IAAM,EAAK,OAAO,OAAO,SAAS,cAAc,MAAO,CAAE,YAAa,EAAQ,EAE9E,EAAO,YAAa,MAAU,CAC5B,EAAO,MAAQ,EAEf,IAAM,EAAO,SAAS,cAA+B,WACrD,GAAM,SAEN,EAAa,UAAU,OAAO,OAC/B,GAED,EAAS,OAAO,EACjB,CAED,EAAiB,OAAO,EACzB,OAAQ,EAAO,CACd,QAAQ,MAAM,uCAAwC,EACvD,CACF,EAEK,EAAS,SAAS,eAAe,KACvC,EAAc,GAEd,IAAIC,EAEJ,EAAO,QAAS,MAAc,CAC5B,aAAa,GAEb,IAAM,EAAQ,EAAO,MACf,EAAY,EAAS,kBAAoB,EAE3C,EAAM,OAAS,IAEnB,EAAY,OAAO,WAAW,SAAY,CACpC,IAAU,EAAO,OACnB,MAAM,EAAa,EAAQ,EAE9B,EAAE,KACJ,GAED,MAAMC,EAAmC,SAAS,cAA2B,iBACvEC,EAA4C,SAAS,cAAgC,oBACvF,GACF,EAAO,QAAS,EAAS,GAAyB,CAChD,IAAM,EAAY,CAAC,GAAG,EAAiB,SAAS,CAE1C,EAAe,EAAU,UAAW,GAAS,EAAK,UAAU,SAAS,WACvE,EAAkB,GAEtB,OAAQ,EAAM,IAAd,CACE,IAAK,UAAW,CACd,IAAM,EAAc,EAAU,GAC1B,GAAe,GAAgB,GACjC,EAAY,UAAU,OAAO,UAI/B,GAAmB,EAAe,EAAI,EAAU,QAAU,EAAU,OACpE,KACD,CACD,IAAK,YAAa,CAChB,IAAM,EAAc,EAAU,GAC1B,GAAe,GAAgB,GACjC,EAAY,UAAU,OAAO,UAE/B,GAAmB,EAAe,GAAK,EAAU,OACjD,KACD,CACD,IAAK,MACL,IAAK,QACC,GACF,EAAa,UAAU,OAAO,QAEhC,MACF,QACE,KACH,CAED,GAAI,IAAoB,GAAI,CAC1B,IAAM,EAAe,EAAU,GAC/B,GAAI,IACF,EAAa,UAAU,IAAI,UAEvB,CAAC,EAAa,UAAU,SAAS,kBAAkB,CACrD,IAAM,EAAS,SAAS,eAAe,KACnC,IACF,EAAO,MAAQ,EAAa,aAAe,GAE9C,CAEJ,CACF"}